"use strict";(self.webpackChunksf_documentation=self.webpackChunksf_documentation||[]).push([[2763],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return c}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(a),c=r,g=u["".concat(o,".").concat(c)]||u[c]||m[c]||i;return a?n.createElement(g,l(l({ref:t},d),{},{components:a})):n.createElement(g,l({ref:t},d))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},178:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return d},default:function(){return u}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),l=["components"],s={sidebar_label:"Feature Extraction"},o="Feature Extraction",p={unversionedId:"Log_management/feature_extraction",id:"Log_management/feature_extraction",isDocsHomePage:!1,title:"Feature Extraction",description:"Feature Extraction allows processing of  unstructured logs and enhances it by adding metadata extracted from the  log. Users can provide extractions rules for specific logs using REGEX  patterns. Search patterns as explained in the Log Overview Search  section, are used to uniquely identify the logs, to which a specific  extraction rule is applied.",source:"@site/docs/Log_management/feature_extraction.md",sourceDirName:"Log_management",slug:"/Log_management/feature_extraction",permalink:"/docs/Log_management/feature_extraction",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/Log_management/feature_extraction.md",tags:[],version:"current",frontMatter:{sidebar_label:"Feature Extraction"},sidebar:"tutorialSidebar",previous:{title:"Log Overview Search",permalink:"/docs/Log_management/log_overview"},next:{title:"Archival",permalink:"/docs/Log_management/archival"}},d=[{value:"Examples",id:"examples",children:[]},{value:"Extract Group",id:"extract-group",children:[]},{value:"Extract Pair",id:"extract-pair",children:[]},{value:"Tools and Tips",id:"tools-and-tips",children:[]}],m={toc:d};function u(e){var t=e.components,a=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"feature-extraction"},"Feature Extraction"),(0,i.kt)("p",null,"Feature Extraction allows processing of  unstructured logs and enhances it by adding metadata extracted from the  log. Users can provide extractions rules for specific logs using REGEX  patterns. Search patterns as explained in the Log Overview Search  section, are used to uniquely identify the logs, to which a specific  extraction rule is applied."),(0,i.kt)("p",null,"For example consider the following log message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Invalid user dsp from 221.12.107.26 port 32041\n")),(0,i.kt)("p",null,"The above log has the following metadata embedded in it, ","<","username",">",", ","<","hostaddress",">"," and the ","<","sourceport",">"," as highlighted below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Invalid user dsp from 221.12.107.26 port 32041\n")),(0,i.kt)("p",null,"To identify this log message, a search ",(0,i.kt)("em",{parentName:"p"},"string invalid && from && port")," can be used. To extract the ","<","username",">"," from this log, extraction operators, EV or EP or EG can be used."),(0,i.kt)("p",null,"EV \u2013 extract values, extract values identified by a REGEX pattern from a field and save it in new user defined fields"),(0,i.kt)("p",null,"EG \u2013 extract a group of values from a field identified by REGEX pattern groups and save it in new user defined fields"),(0,i.kt)("p",null,"EP \u2013  extract key value pairs from a field, user specifies REGEX to identify  the separator between key and value and also the separator between  key-value pairs"),(0,i.kt)("p",null,"These will be explained in more details in the following sections."),(0,i.kt)("p",null,"General syntax for feature extraction is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[<field>:<search string> with] EV(\u2026..)\n[<field>:<search string> with] EG(\u2026..)\n[<field>:<search string> with] EP(\u2026..)\n")),(0,i.kt)("p",null,"Note that if the extraction is qualified by a search, \u201c",(0,i.kt)("em",{parentName:"p"},"with EV"),"\u201d or \u201cwith EG\u201d or \u201c",(0,i.kt)("em",{parentName:"p"},"with EP"),"\u201d should be used to define the extraction operation. If there is no search string, \u201c",(0,i.kt)("em",{parentName:"p"},"EV"),"\u201d or \u201c",(0,i.kt)("em",{parentName:"p"},"EG"),"\u201d or \u201c",(0,i.kt)("em",{parentName:"p"},"EP"),"\u201d can be used to define the extraction operation."),(0,i.kt)("p",null,"SnappyFlow provides a list of buit-in regex patterns, commonly used for  extraction. These built-in pattern names can be used in place of REGEX.  Built-in patterns and their usage is explained in later sections."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Extract Values")),(0,i.kt)("p",null,"In the above example, to extract ","<","username",">",", the following can be done:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Invalid && user && port with EV(message,/(?<=user )\\w+/,string,username)\n")),(0,i.kt)("p",null,"The Extract-Value (EV) construct, uses 4 parameters, ",(0,i.kt)("em",{parentName:"p"},"field, pattern, type, name(s)"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Use"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"field"),(0,i.kt)("td",{parentName:"tr",align:null},"field name to which the extraction is applied, in this case message field of the log")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"pattern"),(0,i.kt)("td",{parentName:"tr",align:null},"REGEX pattern which identifies the extraction, in this case a REGEX string enclosed within \u201c/\u201d; /(?<=user )\\w+/. This pattern means, a word \u2013 string of alpha-numeric characters \u2013 which appears immediately after the string \u201cuser \u201c")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"type"),(0,i.kt)("td",{parentName:"tr",align:null},"once the value is extracted, the type to be associated with the extracted value. The field/value pair created in the JSON, will use this information.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name(s)"),(0,i.kt)("td",{parentName:"tr",align:null},"field names coma separated; extraction pattern may match multiple positions in the log message. Each matched value is extracted and stored in the same order as they are matched. If a specific value should be skipped, then use \u201c-\u201c as the field name.")))),(0,i.kt)("h3",{id:"examples"},"Examples"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"EV(message, /\\d+\\.\\d+\\.\\d+\\.\\d+/, string, ip_addr)\n")),(0,i.kt)("p",null,"Extract IP address from field message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"message": "DHCPACK from 172.31.32.1 (xid=0x381e913e)",\u201cip_addr\u201d: \u201c172.31.32.1\u201d}\n{"message": "DHCPREQUEST on eth0 to 172.31.32.1 port 67 (xid=0x381e913e)", \u201cip_addr\u201d:\u201c172.31.32.1\u201d}\n{"message": "Received disconnect from 167.114.226.137 port 47545:11: [preauth]", \u201cip_addr\u201d:\u201c167.114.226.137\u201d}\n{"message": "Disconnected from 167.71.217.175 port 46180 [preauth]",\u201cip_addr\u201d: \u201c167.71.217.175\u201d}\n{"message": "Received disconnect from 51.91.159.46 port 33914:11: [preauth]",\u201cip_addr\u201d:\u201c51.91.159.46\u201d}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"EV(log_msg, /\\d+(.\\d+)*(?=ms)/, float, delay)\n")),(0,i.kt)("p",null,"Extract delay values from the field \u201clog_msg\u201d. Delay value is identified by the pattern (a) one digit string, immediately followed by string \u201cms\u201d OR (b) two digit strings, each separated by \u201c.\u201d and second digit string is immediately followed by string \u201cms\u201d. Save extracted value in field named delay."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{" log_msg": "Received request from 10.11.100.29 and re-directed to 33.229.79.17 in 10.34ms", \u201cdelay\u201d: 10.34}\n{"log_msg": "Latency time is 5ms",\u201cdelay\u201d: 5}\n{"log_msg": "Process 2131 completed in 50s"} \u2013 *nothing is extracted from this message*\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},'("received request from" && "re-directed") with EV(log_msg, /\\d+',".","\\d+",".","\\d+",".","\\d+/, string, -,rd_ip_addr)")),(0,i.kt)("p",null,"Extract IP addresses from log_msg field. Skip the first extraction and save the second extraction to field named ",(0,i.kt)("em",{parentName:"p"},"rd_ip_addr"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"log_msg": "Received request from 10.11.100.29 and re-directed to 33.229.79.17 in 10.34ms",\u201crd_ip_addr\u201d: "33.229.79.17\u201d}\n')),(0,i.kt)("h3",{id:"extract-group"},"Extract Group"),(0,i.kt)("p",null,"Extract Group (EG) construct allow users to specify a pattern with multiple groups and extract the value of each group into a separate field. In Extract Value a single pattern contained a single group, but this single group could match multiple values in the field. This concept will be better understood through examples."),(0,i.kt)("p",null,"EG construct uses, following parameters:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Use"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"field"),(0,i.kt)("td",{parentName:"tr",align:null},"field name to which the extraction is applied, in this case message field of the log")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"pattern"),(0,i.kt)("td",{parentName:"tr",align:null},"REGEX pattern which identifies the extraction groups. Pattern is enclosed in a pair of \u201c/\u201d. In the REGEX pattern the group to be extracted is enclosed in parenthesis \u201c()\u201d.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name:type"),(0,i.kt)("td",{parentName:"tr",align:null},"a comma separated list of name:type tuples which specify name of the extracted group and its type. Type can be int, float or string. If no type is specified, it is assumed to be string.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'EG(message, /(\\d+.\\d+.\\d+.\\d+) - \\[(.*)\\] "(\\w+) ([^\\s]+) ([^\\s"]+)" (\\d+) (\\d+) "-" "(.*)" "-"/, host, httpd_timestamp, method, path, header, code:int, size:int, agent)\n')),(0,i.kt)("p",null,"The example illustrates extracting information from an nginx access log, which contains the host sending the request, time at which the request was received, HTTP method, request Path, header version, response code, size and the agent making request. The response code, and size are integer values, whereas the other extractions are string type values. Patterns corresponding to these groups are highlighted in the above EG construct."),(0,i.kt)("p",null,"Note: the group REGEX patterns are enclosed in \u201c()\u201d, strings matching each of those patterns are extracted and placed in the field name provided in the same order they appear."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n"message": "172.31.31.45 - [06/May/2020:11:44:41] \\"GET /owners/2 HTTP/1.1\\" 200 4964\n\\"-\\" \\"Apache-HttpClient/4.5.7 (Java/1.8.0_242)\\" \\"-\\" rt=14.717 uct=0.000 uht=14.716\nurt=14.716",\n"host": \u201c172.31.31.45\u201d,\n"httpd_timestamp": "06/May/2020:11:44:41",\n"method": "GET",\n"path": "/owners/2",\n"header": "HTTP/1.1",\n"code": 302,\n"size": 4964,\n"agent": "Apache-HttpClient/4.5.7 (Java/1.8.0_242)"\n}\n{\n"message": "172.31.81.81 - [06/May/2020:11:44:41] \\"POST /owners/new HTTP/1.1\\" 201\n24 \\"-\\" \\"Mozilla/5.0 (Windows NT 10.0; WOW64)\\" \\"-\\" rt=1.088 uct=0.000 uht=1.088\nurt=1.088",\n"host": \u201c172.31.81.81\u201d, \n"httpd_timestamp": "06/May/2020:11:44:41",\n"method": "POST",\n"path": "/owners/new",\n"header": "HTTP/1.1",\n"code": 201,\n"size": 24,\n"agent": "Mozilla/5.0 (Windows NT 10.0; WOW64)"\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"EG(message, /TTY=\\w+ ; PWD=([^\\s]+) ; USER=(\\w+) ; COMMAND=(.*)$/, path, username, cmd)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n"message": "root : TTY=unknown ; PWD=/home/centos ; USER=root ; COMMAND=/bin/rm \u2013rf\njmeter.log",\n"pwd": "/home/centos",\n"username": "root",\n"cmd": "/bin/rm -rf jmeter.log"\n}\n{\n"message": "centos : TTY=unknown ; PWD=/home/kevin ; USER=adam ; COMMAND=/bin/rm -\nrf jmeter.log ",\n"pwd": "/home/kevin",\n"username": "adam",\n"cmd": "/bin/rm -rf jmeter.log"\n}\n')),(0,i.kt)("h3",{id:"extract-pair"},"Extract Pair"),(0,i.kt)("p",null,"Applications often use logs to dump their internal statistics for debugging purposes. Most often, such logs will contain expressions like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"<name1>:<value1>, <name2>:<value2>, \u2026..\n")),(0,i.kt)("p",null,"OR"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"<name1>=<value1>; <name2>=<value2>;\u2026.\n")),(0,i.kt)("p",null,"In such logs, the field-value pairs can be identified with a value ",(0,i.kt)("em",{parentName:"p"},"separator")," and a pair ",(0,i.kt)("em",{parentName:"p"},"delimiter"),". In the first example value separator is \u201c:\u201d and pair delimiter is \u201c,\u201d; whereas in the second example, value separator is \u201c=\u201d and pair delimiter is \u201c;\u201d."),(0,i.kt)("p",null,"General syntax used in Extract Pairs is:"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"EP(field, /pair_delimiter/, /value_separator/, convert=","[..]",", include=","[..]",", exclude=","[..]",")")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Use"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"field"),(0,i.kt)("td",{parentName:"tr",align:null},"field name to which the extraction is applied, example: ",(0,i.kt)("strong",{parentName:"td"},"*message","*")," field of the log")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"pair_delimiter"),(0,i.kt)("td",{parentName:"tr",align:null},"REGEX pattern which identifies the field-value pair delimiter. Pattern is enclosed in a pair of \u201c/\u201d.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"value_separator"),(0,i.kt)("td",{parentName:"tr",align:null},"REGEX pattern which identifies the separator between field and value. Pattern is enclosed in a pair of \u201c/\u201d.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"convert=[]"),(0,i.kt)("td",{parentName:"tr",align:null},"a list of field:type tuples, which specify how to convert the field values. If nothing is specified, all fields are considered have a string type value. ",(0,i.kt)("strong",{parentName:"td"},"Note:")," the field names are the names extracted from the log message itself. Example is ",(0,i.kt)("em",{parentName:"td"},"convert=(field1:int,field2:float)"),". This is an optional field, all values are converted to string type, if not specified.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"include=[]"),(0,i.kt)("td",{parentName:"tr",align:null},"if only selected fields from the extraction are to be added to the log document, list those field names. ",(0,i.kt)("strong",{parentName:"td"},"Note:")," include and exclude lists can not both be present at the same time. An optional field and can be omitted.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"exclude=[]"),(0,i.kt)("td",{parentName:"tr",align:null},"if selected fields from the extraction are not to be added to the log document, list those field names. ",(0,i.kt)("strong",{parentName:"td"},"Note:")," include and exclude lists can not both be present at the same time. An optional field and can be omitted.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"EP(message, /,/, /=/, convert=[price:int])\n")),(0,i.kt)("p",null,"From the field message, extract field-value pairs where pair_delimiter is \u201c,\u201d and value separator is \u201c=\u201d. Convert the value for field \u201cprice\u201d to integer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n"message": "name=Kevin,user_id=3212,order_id=234,price=240.56",\n"name": "Kevin", \n"user_id": "3212", \n"order_id": "234", \n"price": 241\n}\n{\n"message": "name=larry,user_id=1111,order_id=100,price=123",\n"name": "larry",\n"user_id": "1111",\n"order_id": "100",\n"price": 123\n}\n{\n"message": "process completed in 20s, and details=HEXA3413",\n"and details": "HEXA3413"\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," in the above example"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Field \u201cprice\u201d, if present is converted to Integer. In the 3 rd message field, \u201cprice\u201d is not present"),(0,i.kt)("li",{parentName:"ul"},"In the 3 rd message, notice that the field name is taken as \u201cand details\u201d. This is because the pair delimiter was specified as \u201c,\u201d and anything between \u201c,\u201d (pair delimiter) and \u201c=\u201d (value separator) is taken as a field name")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"EP(message, /,|(.*,\\s+and)/, /=/, exclude=[name], convert=[price:float, order_id])\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"From the field message, extract field-value pairs delimited by text matching the pattern /,|(.*,\\s+and)/ and has a value separator \u201c=\u201d. Note that the pair delimiter has a REGEX pattern which defines multiple delimiters. Each delimiter is separated by \u201c|\u201d.\n\nOptions specified here are:\n\u201c,\u201d \u2013 comma\n\nOR\n\n\u201c.*,\\s+and\u2019 - a string with any number of characters(.*), followed by a \u201c,\u201d followed by any number of white space characters(\\s+) and followed by the string \u201cand\u201d.\n")),(0,i.kt)("p",null,"Following log messages will illustrate the use of this extraction"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n"message": "name=Kevin,user_id=3212,order_id=234,price=240.56",\n"user_id": "3212",\n"order_id": 234,\n"price": 240.56\n}\n{\n"message": "name=larry,user_id=1111,order_id=100,price=123",\n"user_id": "1111", \n"order_id": 100,\n"price": 123\n}\n{\n"message": "process completed in 20s, and details=HEXA3413",\n"details": "HEXA3413"\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In the 1 st and 2 nd example messages, pair delimiter used was \u201c,\u201d."),(0,i.kt)("li",{parentName:"ul"},"In the 3 rd example message, the pair delimiter is \u201cprocess completed in 20s, and\u201d"),(0,i.kt)("li",{parentName:"ul"},"Also note, in messages 1 and 2, the field \u201cname\u201d was extracted, but was not added to the output document, because of the \u201cexclude\u201d option.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"message: (user_id && price) with EP(message, /,/, /=/, include=[price])\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n"message": "name=Kevin,user_id=3212,order_id=234,price=240.56",\n"price": \u201c240.56\u201d\n}\n{\n"message": "name=larry,user_id=1111,order_id=100,price=123",\n"price": \u201c123\u201d\n}\n{\n"message": "process completed in 20s, and details=HEXA3413"\n}\n')),(0,i.kt)("p",null,"Since ",(0,i.kt)("strong",{parentName:"p"},"include")," option had the field \u201cprice\u201d, only those documents where field \u201cprice\u201d was found were updated. 3 rd document though matched the delimiter and separator, did not have the field \u201cprice\u201d."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 4")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"EP(message, /(.*PID.*?(?=\\w+=))|(\\})|(\\{)|(\\s(?=\\w+=))/, /=/, exclude=[ startTime, endTime], convert=[count, minimum: float, mean: float, maximum: float])\n")),(0,i.kt)("p",null,"Another example using a complex delimiter, with exclude option and convert options.\nMultiple pair delimiters are used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n"message": "StatisticsLogTask - PID1 - context=Execution Fill {subContext=Order Update section=Top Level startTime=2019-12-17 23:59 endTime=2019-12-20 00:00} count=3\nminimum=1.0 mean=5.0 maximum=21.0",\n"context": "Execution Fill", \n"subContext": "Order Update",\n"section": "Top Level", \n"count": 3,\n"minimum": 1,\n"maximum": 21,\n"mean": 5\n}\n{\n"message": "StatisticsLogTask - PID2 - context=Execution Fill {subContext=Order Placed section=Mid Level startTime=2019-12-17 23:59 endTime=2019-12-20 00:00 count=6\nminimum=0.813 mean=7.9 maximum=13.0}",\n"context": "Execution Fill", "subContext": "Order Placed",\n"section": "Mid Level", "count": 6,\n"minimum": 0.813, "maximum": 13, "mean": 7.9\n}\n')),(0,i.kt)("p",null,"In the extraction, multiple pair delimiters were specified"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"/(.*PID.*?(?=\\w+=))|(\\})|(\\{)|(\\s(?=\\w+=))/\n")),(0,i.kt)("p",null,"StatisticsLogTask - PID1 - context=Execution Fill (subContext=Order Update section=Top Level startTime=2019-12-17 23:59 endTime=2019-12-20 00:00} count=3 minimum=1.0 mean=5.0 maximum=21.0 "),(0,i.kt)("p",null,"StatisticsLogTask - PID2 - context=Execution Fill (subContext=Order Place section=Mid Level startTime=2019-12-17 23:59 endTime=2019-12-20 00:00} count=6 minimum=0.813 mean=7.3 maximum=13.0 "),(0,i.kt)("p",null,"Value pairs identified by the pair delimiter pattern is shown in the above picture."),(0,i.kt)("p",null,"Though startTime and endTime are extracted, but they are excluded."),(0,i.kt)("h3",{id:"tools-and-tips"},"Tools and Tips"),(0,i.kt)("p",null,"Java REGEX testing tools can be used to validate the REGEX patterns used for extractions. A web tool like ",(0,i.kt)("a",{parentName:"p",href:"https://www.freeformatter.com/java-regex-tester.html"},"https://www.freeformatter.com/java-regex-tester.html")," can be used for this."),(0,i.kt)("p",null,"Pattern used in extract values (EV) should match the sub-strings you intend to extract. For example, to extract the timestamps from the following message, a pattern like below can be used"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"/\\d+-\\d+- \\d+\\s+\\d+:\\d+/\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Extract Value Pattern")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"\\d+-\\d+-\\d+\\s+\\d+:\\d+\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"String: StatisticsLogTask - PID1 - context=Execution Fill {subContext=Order Update section=Top Level startTime=2019-12-17 23:59 endTime=2019-12-20 00:00} count=3 minimum=1.0 mean=5.0 maximum=21.0\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"StatisticsLogTask - PID2 - Context = Execution Fill (subContext=Order Place section=Mid Level startTime=2019-12-17 23:59 endTime=2019-12-20 00:00 count=6 minimum=0.813 mean=7.9 maximum=13.0\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Match #"),(0,i.kt)("th",{parentName:"tr",align:null},"Group index"),(0,i.kt)("th",{parentName:"tr",align:null},"Start index"),(0,i.kt)("th",{parentName:"tr",align:null},"End index"),(0,i.kt)("th",{parentName:"tr",align:null},"Group content"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"103"),(0,i.kt)("td",{parentName:"tr",align:null},"119"),(0,i.kt)("td",{parentName:"tr",align:null},"2019-12-17 23:59")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"128"),(0,i.kt)("td",{parentName:"tr",align:null},"144"),(0,i.kt)("td",{parentName:"tr",align:null},"2019-12-20 00:00")))),(0,i.kt)("p",null,"Extract Group allows to apply a REGEX to the field and extract only the groups identified (i.e. patterns enclosed in parentheses). As an example the following group REGEX when applied to the string below will result in the following groups."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Extract group pattern")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'(\\d+\\.\\d+\\.\\d+\\.\\d+) - - \\[[^\\]]* \\+\\d+\\] \\\\\\\\\\\\\\"POST \\/topics\\/(\\w+)-(\\w+) HTTP/1.0\\\\\\\\\\\\\\"(\\d+) (\\d+) (\\d+)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'String: 10.233.117.0 - - [26/Oct/2020:22:30:00 +0000] \\\\\\"POST /topics/metric-grqqwwi7 HTTP/1.0\\\\\\"200 12602 12 (io.confluent.rest-utils.requests)\n')),(0,i.kt)("p",null,"Copy the pattern and string to the java-regex-tester. Observe the resultant matches and groups. In Extract Group, the values extracted in non-zero group index are used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'10.233.177.0 - - [26/Oct/2020:22:30:00 +0000]  \\\\\\"Post  /topica/metric-grqqwwi7  HTTP/1.0\\\\\\"  200  12602  12(io.confluent.reat-utile.requests)\n')),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Match #"),(0,i.kt)("th",{parentName:"tr",align:null},"Group index"),(0,i.kt)("th",{parentName:"tr",align:null},"Start index"),(0,i.kt)("th",{parentName:"tr",align:null},"End index"),(0,i.kt)("th",{parentName:"tr",align:null},"Group content"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"106"),(0,i.kt)("td",{parentName:"tr",align:null},"10.233.117.0--","[26/Oct/2000:22:30:00 +0000]"," ","\\",'\\"POST /topics/metric-grqqwwi7 HTTP/1.0',"\\","\\","* 200 1260212")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"12"),(0,i.kt)("td",{parentName:"tr",align:null},"10.233.117.0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"63"),(0,i.kt)("td",{parentName:"tr",align:null},"69"),(0,i.kt)("td",{parentName:"tr",align:null},"metric")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"70"),(0,i.kt)("td",{parentName:"tr",align:null},"78"),(0,i.kt)("td",{parentName:"tr",align:null},"grqqwwi7")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"92"),(0,i.kt)("td",{parentName:"tr",align:null},"95"),(0,i.kt)("td",{parentName:"tr",align:null},"200")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"5"),(0,i.kt)("td",{parentName:"tr",align:null},"96"),(0,i.kt)("td",{parentName:"tr",align:null},"101"),(0,i.kt)("td",{parentName:"tr",align:null},"12602")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"6"),(0,i.kt)("td",{parentName:"tr",align:null},"103"),(0,i.kt)("td",{parentName:"tr",align:null},"106"),(0,i.kt)("td",{parentName:"tr",align:null},"12")))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To extract value pairs, pair-delimiter should match the boundaries and all other symbols which are needed to split the string into an array of pairs. Each pair is again split, based on value- separator pattern")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"SnappyFlow provides following built-in regex patterns, these built-in patterns can be used in place of a REGEX required in EV, EP or EG feature extraction constructs. Built-in pattern names are encapsulated in \u201c$\u201d "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"$hostname$ - hostname string, e.g.apmmanager.snappyflow.io\n$url$ - URL, e.g. https://apmmanager.snappyflow.io\n$file_path$ - UNIX file path, e.g. /usr/share/nginx/html/theme-chrome.js\n$float$ - floating point number, e.g.31.45\n$integer$ - integer number, e.g. 19345\n$alphanumeric$ - alpha-numeric characters, e.g. admin1\n$alphanumericspecial$ - alpha-numeric with hyphen and underscore, e.g. date_time\n$string$ - a string encapsulated in \u2018 (single quote) or \u201c (double quote)\n$date$ - date string, e.g. 02-04-2020\n$datetime$ - date with time string, e.g. 02-04-20 21:41:59\n$time$ - time string, e.g. 21:41:59\n$ipv4addr$ - IPv4 Address, e.g. 172.31.22.98\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Example extraction with built-in regex patterns"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'message: "*72281 open() "/usr/share/nginx/html/theme-chrome.js" failed (2: No such file or directory), client: 172.31.22.98, server: _, request: "GET /theme-chrome.js HTTP/1.1", host: "apmmanager.snappyflow.io", referrer: \u201chttps://apmmanager.snappyflow.io/\u201d\n\nExtraction\nmessage:"No such file or directory" with EG(message,/($integer$) open\\(\\) \\"($file_path$)\\" failed \\(2: No such file or directory\\), client: ($ipv4addr$), server: ([^,]*), request: \\"([^\\"]*)\\", host: \\"($hostname$)\\", referrer: \\"($url$)\\"/,m_size:int, m_file, m_client, m_server, m_request, m_host, m_referrer)\n\nThe extraction operation above will extract the fields m_size: 72281, m_file: /usr/share/nginx/html/theme-chrome.js, m_client: 172.31.22.98, m_server: _, m_request: GET /theme-chrome.js HTTP/1.1, m_host: apmmanager.snappyflow.io and m_referrer: https://apmmanager.snappyflow.io/\n')))))}u.isMDXComponent=!0}}]);